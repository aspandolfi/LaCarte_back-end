
import { QueryRunner } from "../../query-runner/QueryRunner";
import { ObjectLiteral } from "../../common/ObjectLiteral";
import { ColumnSchema } from "../../schema-builder/schema/ColumnSchema";
import { TableSchema } from "../../schema-builder/schema/TableSchema";
import { ForeignKeySchema } from "../../schema-builder/schema/ForeignKeySchema";
import { IndexSchema } from "../../schema-builder/schema/IndexSchema";
import { MysqlDriver } from "./MysqlDriver";
import { Connection } from "../../connection/Connection";
import { ReadStream } from "../../platform/PlatformTools";
import { EntityManager } from "../../entity-manager/EntityManager";
import { InsertResult } from "../InsertResult";
/**
 * Runs queries on a single mysql database connection.
 */
export declare class MysqlQueryRunner implements QueryRunner {
    /**
     * Database driver used by connection.
     */
    driver: MysqlDriver;
    /**
     * Connection used by this query runner.
     */
    connection: Connection;
    /**
     * Isolated entity manager working only with current query runner.
     */
    manager: EntityManager;
    /**
     * Indicates if connection for this query runner is released.
     * Once its released, query runner cannot run queries anymore.
     */
    isReleased: boolean;
    /**
     * Indicates if transaction is in progress.
     */
    isTransactionActive: boolean;
    /**
     * Stores temporarily user data.
     * Useful for sharing data with subscribers.
     */
    data: {};
    /**
     * Real database connection from a connection pool used to perform queries.
     */
    protected databaseConnection: any;
    /**
     * Promise used to obtain a database connection from a pool for a first time.
     */
    protected databaseConnectionPromise: Promise<any>;
    /**
     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
     */
    protected sqlMemoryMode: boolean;
    /**
     * Sql-s stored if "sql in memory" mode is enabled.
     */
    protected sqlsInMemory: (string | {
        up: string;
        down: string;
    })[];
    /**
     * Mode in which query runner executes.
     * Used for replication.
     * If replication is not setup its value is ignored.
     */
    protected mode: "master" | "slave";
    constructor(driver: MysqlDriver, mode?: "master" | "slave");
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */
    connect(): Promise<any>;
    /**
     * Releases used database connection.
     * You cannot use query runner methods once its released.
     */
    release(): Promise<void>;
    /**
     * Starts transaction on the current connection.
     */
    startTransaction(): Promise<void>;
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */
    commitTransaction(): Promise<void>;
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */
    rollbackTransaction(): Promise<void>;
    /**
     * Executes a raw SQL query.
     */
    query(query: string, parameters?: any[]): Promise<any>;
    /**
     * Returns raw data stream.
     */
    stream(query: string, parameters?: any[], onEnd?: Function, onError?: Function): Promise<ReadStream>;
    /**
     * Insert a new row with given values into the given table.
     * Returns value of the generated column if given and generate column exist in the table.
     */
    insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult>;
    /**
     * Updates rows that match given conditions in the given table.
     */
    update(tableName: string, valuesMap: ObjectLiteral, conditions: ObjectLiteral): Promise<void>;
    /**
     * Deletes from the given table by a given conditions.
     */
    delete(tableName: string, conditions: ObjectLiteral | string, maybeParameters?: any[]): Promise<void>;
    /**
     * Inserts rows into the closure table.
     */
    insertIntoClosureTable(tableName: string, newEntityId: any, parentId: any, hasLevel: boolean): Promise<number>;
    /**
     * Loads given table's data from the database.
     */
    loadTableSchema(tableName: string): Promise<TableSchema | undefined>;
    /**
     * Loads all tables (with given names) from the database and creates a TableSchema from them.
     */
    loadTableSchemas(tableNames: string[]): Promise<TableSchema[]>;
    /**
     * Checks if table with the given name exist in the database.
     */
    hasTable(table: TableSchema | string): Promise<boolean>;
    /**
     * Checks if column with the given name exist in the given table.
     */
    hasColumn(table: TableSchema | string, column: ColumnSchema | string): Promise<boolean>;
    /**
     * Creates a schema if it's not created.
     */
    createSchema(): Promise<void>;
    /**
     * Creates a new table from the given table schema and column schemas inside it.
     */
    createTable(table: TableSchema): Promise<void>;
    /**
     * Drop the table.
     */
    dropTable(table: TableSchema | string): Promise<void>;
    /**
     * Creates a new column from the column schema in the table.
     */
    addColumn(tableSchemaOrName: TableSchema | string, column: ColumnSchema): Promise<void>;
    /**
     * Creates a new columns from the column schema in the table.
     */
    addColumns(tableSchemaOrName: TableSchema | string, columns: ColumnSchema[]): Promise<void>;
    /**
     * Renames column in the given table.
     */
    renameColumn(tableSchemaOrName: TableSchema | string, oldColumnSchemaOrName: ColumnSchema | string, newColumnSchemaOrName: ColumnSchema | string): Promise<void>;
    /**
     * Changes a column in the table.
     */
    changeColumn(tableSchemaOrName: TableSchema | string, oldColumnSchemaOrName: ColumnSchema | string, newColumn: ColumnSchema): Promise<void>;
    /**
     * Changes a column in the table.
     */
    changeColumns(table: TableSchema, changedColumns: {
        newColumn: ColumnSchema;
        oldColumn: ColumnSchema;
    }[]): Promise<void>;
    /**
     * Drops column in the table.
     */
    dropColumn(table: TableSchema, column: ColumnSchema): Promise<void>;
    /**
     * Drops the columns in the table.
     */
    dropColumns(table: TableSchema, columns: ColumnSchema[]): Promise<void>;
    /**
     * Updates table's primary keys.
     */
    updatePrimaryKeys(tableSchema: TableSchema): Promise<void>;
    /**
     * Creates a new foreign key.
     */
    createForeignKey(tableSchemaOrName: TableSchema | string, foreignKey: ForeignKeySchema): Promise<void>;
    /**
     * Creates a new foreign keys.
     */
    createForeignKeys(tableSchemaOrName: TableSchema | string, foreignKeys: ForeignKeySchema[]): Promise<void>;
    /**
     * Drops a foreign key from the table.
     */
    dropForeignKey(tableSchemaOrName: TableSchema | string, foreignKey: ForeignKeySchema): Promise<void>;
    /**
     * Drops a foreign keys from the table.
     */
    dropForeignKeys(tableSchemaOrName: TableSchema | string, foreignKeys: ForeignKeySchema[]): Promise<void>;
    /**
     * Creates a new index.
     */
    createIndex(table: TableSchema | string, index: IndexSchema): Promise<void>;
    /**
     * Drops an index from the table.
     */
    dropIndex(table: TableSchema | string, index: IndexSchema | string): Promise<void>;
    /**
     * Truncates table.
     */
    truncate(table: TableSchema | string): Promise<void>;
    /**
     * Removes all tables from the currently connected database.
     * Be careful using this method and avoid using it in production or migrations
     * (because it can clear all your database).
     */
    clearDatabase(): Promise<void>;
    /**
     * Enables special query runner mode in which sql queries won't be executed,
     * instead they will be memorized into a special variable inside query runner.
     * You can get memorized sql using getMemorySql() method.
     */
    enableSqlMemory(): void;
    /**
     * Disables special query runner mode in which sql queries won't be executed
     * started by calling enableSqlMemory() method.
     *
     * Previously memorized sql will be flushed.
     */
    disableSqlMemory(): void;
    /**
     * Gets sql stored in the memory. Parameters in the sql are already replaced.
     */
    getMemorySql(): (string | {
        up: string;
        down: string;
    })[];
    /**
     * Executes sql used special for schema build.
     */
    protected schemaQuery(upQuery: string, downQuery: string): Promise<void>;
    /**
     * Database name shortcut.
     */
    protected readonly dbName: string;
    /**
     * Parametrizes given object of values. Used to create column=value queries.
     */
    protected parametrize(objectLiteral: ObjectLiteral): string[];
    /**
     * Builds a part of query to create/change a column.
     */
    protected buildCreateColumnSql(column: ColumnSchema, skipPrimary: boolean): string;
}
