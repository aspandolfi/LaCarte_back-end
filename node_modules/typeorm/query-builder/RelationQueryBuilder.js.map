{"version":3,"sources":["../../src/query-builder/RelationQueryBuilder.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+CAA4C;AAE5C;;;;GAIG;AACH;IAAkD,wCAAoB;IAAtE;;IAkEA,CAAC;IAhEG,4EAA4E;IAC5E,6BAA6B;IAC7B,4EAA4E;IAE5E;;OAEG;IACH,uCAAQ,GAAR;QACI,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;;;;OAKG;IACH,kCAAG,GAAH,UAAI,KAAU;QAEV,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACH,kCAAG,GAAH,UAAI,KAAgB;QAEhB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACH,qCAAM,GAAN,UAAO,KAAgB;QAEnB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACG,sCAAO,GAAb;;;;;;KAEC;IAED;;OAEG;IACG,uCAAQ,GAAd;;;gBACI,sBAAO,EAAE,EAAC;;;KACb;IAEL,2BAAC;AAAD,CAlEA,AAkEC,CAlEiD,2BAAY,GAkE7D;AAlEY,oDAAoB;AAqEjC;;;;;;;;;;;;;GAaG;AACH;;;;;;;;;;;;;;GAcG;AACH;;;;GAIG;AACH,+FAA+F;AAE/F;;;;GAIG;AACH,oHAAoH;AAEpH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAiCO;AAEP;;;;GAIG;AACH,sGAAsG;AAEtG;;;;GAIG;AACH,2HAA2H;AAE3H;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BO;AAEP;;;;GAIG;AACH,oGAAoG;AAEpG;;;;GAIG;AACH,yHAAyH;AAEzH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BO;AAEP;;;;GAIG;AACH,2GAA2G;AAE3G;;;;GAIG;AACH,gIAAgI;AAEhI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAiCO;AAEP;;;;GAIG;AACH,yGAAyG;AAEzG;;;;GAIG;AACH,8HAA8H;AAE9H;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAiCO;AAEP;;;;GAIG;AACH,gHAAgH;AAEhH;;;;GAIG;AACH,qIAAqI;AAErI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BO;AAEP;;;;GAIG;AACH,6IAA6I;AAE7I;;;;GAIG;AACH,kKAAkK;AAElK;;;;;;;;;;OAUO;AAEP;;;;GAIG;AACH,6IAA6I;AAE7I;;;;GAIG;AACH,kKAAkK;AAElK;;;;;;;;;;OAUO;AAEP,4EAA4E;AAC5E,oBAAoB;AACpB,4EAA4E;AAE5E;;;;;;;;;;;;;;;;;OAiBO;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA8BS;AAET,IAAI","file":"RelationQueryBuilder.js","sourcesContent":["import {QueryBuilder} from \"./QueryBuilder\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n *\n * todo: implement all functions using SpecificRepository code.\n */\nexport class RelationQueryBuilder<Entity> extends QueryBuilder<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        return \"\";\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets entity relation's value.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Works only for many-to-one and one-to-one relations.\n     * For many-to-many and one-to-many relations use #add and #remove methods instead.\n     */\n    set(value: any): this {\n\n        return this;\n    }\n\n    /**\n     * Adds (binds) given value to entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    add(value: any|any[]): this {\n\n        return this;\n    }\n\n    /**\n     * Removes (unbinds) given value from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    remove(value: any|any[]): this {\n\n        return this;\n    }\n\n    /**\n     * Gets entity's relation id.\n     */\n    async getIdOf(): Promise<any> {\n\n    }\n\n    /**\n     * Gets entity's relation ids.\n     */\n    async getIdsOf(): Promise<any[]> {\n        return [];\n    }\n\n}\n\n\n/**\n * Repository for more specific operations.\n *\n * @deprecated Don't use it yet\n *\n * todo: most of these methods looks like can be part of query builder functionality\n * todo: maybe instead of SpecificRepository we should have SpecificQueryBuilder? (better name needed)\n * todo: it can be used like createQueryBuilder().specific().setRelation\n * todo: or maybe split specific into multiple different purpose QueryBuilders ? For example RelationQueryBuilder\n * todo: with methods like createQueryBuilder().relation(Post, \"categories\").set(value).add(value).remove(value)\n * todo: add and remove for many-to-many, set for many-to-one and value can be entity or simply entity id or id map\n * todo: also createQueryBuilder().relation(Post, \"categories\").getIdsOf(postIds)\n * todo: also createQueryBuilder().relation(Post, \"categories\").getCountOf(postIds)\n */\n/*export class SpecificRepository<Entity extends ObjectLiteral> {\n\n // -------------------------------------------------------------------------\n // Constructor\n // -------------------------------------------------------------------------\n\n constructor(protected connection: Connection,\n protected metadata: EntityMetadata,\n protected queryRunner?: QueryRunner) {\n }\n\n // -------------------------------------------------------------------------\n // Public Methods\n // -------------------------------------------------------------------------\n */\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async setRelation(relationName: string, entityId: any, relatedEntityId: any): Promise<void>;\n\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async setRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void>;\n\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async setRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\n        if (relation.isManyToMany)\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\n\n        // todo: fix issues with joinColumns[0]\n\n        let table: string, values: any = {}, conditions: any = {};\n        if (relation.isOwning) {\n            table = relation.entityMetadata.tableName;\n            values[relation.joinColumns[0].referencedColumn!.databaseName] = relatedEntityId;\n            conditions[relation.joinColumns[0].referencedColumn!.databaseName] = entityId;\n        } else {\n            table = relation.inverseEntityMetadata.tableName;\n            values[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = relatedEntityId;\n            conditions[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = entityId;\n        }\n\n\n        const usedQueryRunner = this.queryRunner || this.connection.createQueryRunner();\n        await usedQueryRunner.update(table, values, conditions);\n        if (!this.queryRunner) // means created by this method\n            await usedQueryRunner.release();\n    }*/\n\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async setInverseRelation(relationName: string, relatedEntityId: any, entityId: any): Promise<void>;\n\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async setInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void>;\n\n/**\n * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\n * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async setInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        // todo: fix issues with joinColumns[0]\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\n        if (relation.isManyToMany)\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\n\n        let table: string, values: any = {}, conditions: any = {};\n        if (relation.isOwning) {\n            table = relation.inverseEntityMetadata.tableName;\n            values[relation.inverseRelation!.joinColumns[0].databaseName] = relatedEntityId;\n            conditions[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = entityId;\n        } else {\n            table = relation.entityMetadata.tableName;\n            values[relation.joinColumns[0].databaseName] = relatedEntityId;\n            conditions[relation.joinColumns[0].referencedColumn!.databaseName] = entityId;\n        }\n\n        const usedQueryRunner = this.queryRunner || this.connection.createQueryRunner();\n        await usedQueryRunner.update(table, values, conditions);\n        if (!this.queryRunner) // means created by this method\n            await usedQueryRunner.release();\n    }*/\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addToRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addToRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async addToRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        if (!relation.isManyToMany)\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\n\n        const usedQueryRunner = this.queryRunner || this.connection.createQueryRunner();\n        const insertPromises = relatedEntityIds.map(relatedEntityId => {\n            const values: any = {};\n            if (relation.isOwning) {\n                values[relation.junctionEntityMetadata!.columns[0].databaseName] = entityId;\n                values[relation.junctionEntityMetadata!.columns[1].databaseName] = relatedEntityId;\n            } else {\n                values[relation.junctionEntityMetadata!.columns[1].databaseName] = entityId;\n                values[relation.junctionEntityMetadata!.columns[0].databaseName] = relatedEntityId;\n            }\n\n            return usedQueryRunner.insert(relation.junctionEntityMetadata!.tableName, values);\n        });\n        await Promise.all(insertPromises);\n\n        if (!this.queryRunner) // means created by this method\n            await usedQueryRunner.release();\n    }*/\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addToInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addToInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\n\n/**\n * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\n * Should be used when you want quickly and efficiently add a relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async addToInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        if (!relation.isManyToMany)\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\n\n        const usedQueryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            const insertPromises = entityIds.map(entityId => {\n                const values: any = {};\n                if (relation.isOwning) {\n                    values[relation.junctionEntityMetadata!.columns[0].databaseName] = entityId;\n                    values[relation.junctionEntityMetadata!.columns[1].databaseName] = relatedEntityId;\n                } else {\n                    values[relation.junctionEntityMetadata!.columns[1].databaseName] = entityId;\n                    values[relation.junctionEntityMetadata!.columns[0].databaseName] = relatedEntityId;\n                }\n\n                return usedQueryRunner.insert(relation.junctionEntityMetadata!.tableName, values);\n            });\n            await Promise.all(insertPromises);\n\n        } finally {\n            if (!this.queryRunner) // means created by this method\n                await usedQueryRunner.release();\n        }\n    }*/\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async removeFromRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async removeFromRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async removeFromRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        if (!relation.isManyToMany)\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\n\n        // check if given relation entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\n        if (!relatedEntityIds || !relatedEntityIds.length)\n            return Promise.resolve();\n\n        const qb = this.connection.manager\n            .createQueryBuilder(this.queryRunner)\n            .delete()\n            .from(relation.junctionEntityMetadata!.tableName, \"junctionEntity\");\n\n        const firstColumnName = this.connection.driver.escapeColumn(relation.isOwning ? relation.junctionEntityMetadata!.columns[0].databaseName : relation.junctionEntityMetadata!.columns[1].databaseName);\n        const secondColumnName = this.connection.driver.escapeColumn(relation.isOwning ? relation.junctionEntityMetadata!.columns[1].databaseName : relation.junctionEntityMetadata!.columns[0].databaseName);\n\n        relatedEntityIds.forEach((relatedEntityId, index) => {\n            qb.orWhere(`(${firstColumnName}=:entityId AND ${secondColumnName}=:relatedEntity_${index})`)\n                .setParameter(\"relatedEntity_\" + index, relatedEntityId);\n        });\n\n        await qb\n            .setParameter(\"entityId\", entityId)\n            .execute();\n    }*/\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async removeFromInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async removeFromInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\n\n/**\n * Removes a relation between two entities from relation's many-to-many table.\n * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async removeFromInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        if (!relation.isManyToMany)\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\n\n        // check if given entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\n        if (!entityIds || !entityIds.length)\n            return Promise.resolve();\n\n        const qb = this.connection.manager\n            .createQueryBuilder(this.queryRunner)\n            .delete()\n            .from(relation.junctionEntityMetadata!.tableName, \"junctionEntity\");\n\n        const firstColumnName = relation.isOwning ? relation.junctionEntityMetadata!.columns[1].databaseName : relation.junctionEntityMetadata!.columns[0].databaseName;\n        const secondColumnName = relation.isOwning ? relation.junctionEntityMetadata!.columns[0].databaseName : relation.junctionEntityMetadata!.columns[1].databaseName;\n\n        entityIds.forEach((entityId, index) => {\n            qb.orWhere(`(${firstColumnName}=:relatedEntityId AND ${secondColumnName}=:entity_${index})`)\n              .setParameter(\"entity_\" + index, entityId);\n        });\n\n        await qb.setParameter(\"relatedEntityId\", relatedEntityId).execute();\n    }*/\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addAndRemoveFromRelation(relation: string, entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addAndRemoveFromRelation(relation: ((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async addAndRemoveFromRelation(relation: string|((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void> {\n        await Promise.all([\n            this.addToRelation(relation as any, entityId, addRelatedEntityIds),\n            this.removeFromRelation(relation as any, entityId, removeRelatedEntityIds)\n        ]);\n    }*/\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addAndRemoveFromInverseRelation(relation: string, relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n */\n// async addAndRemoveFromInverseRelation(relation: ((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\n\n/**\n * Performs both #addToRelation and #removeFromRelation operations.\n * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\n * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\n\n async addAndRemoveFromInverseRelation(relation: string|((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void> {\n        await Promise.all([\n            this.addToInverseRelation(relation as any, relatedEntityId, addEntityIds),\n            this.removeFromInverseRelation(relation as any, relatedEntityId, removeEntityIds)\n        ]);\n    }*/\n\n// -------------------------------------------------------------------------\n// Protected Methods\n// -------------------------------------------------------------------------\n\n/**\n * Converts entity or entities to id or ids map.\n\n protected convertEntityOrEntitiesToIdOrIds(columns: ColumnMetadata[], entityOrEntities: Entity[]|Entity|any|any[]): any|any[] {\n        if (entityOrEntities instanceof Array) {\n            return entityOrEntities.map(entity => this.convertEntityOrEntitiesToIdOrIds(columns, entity));\n\n        } else {\n            if (entityOrEntities instanceof Object) {\n                return columns.reduce((ids, column) => {\n                    ids[column.databaseName] = column.getEntityValue(entityOrEntities);\n                    return ids;\n                }, {} as ObjectLiteral);\n            } else {\n                return entityOrEntities;\n            }\n        }\n    }*/\n\n/**\n * Extracts unique objects from given entity and all its downside relations.\n\n protected extractObjectsById(entity: any, metadata: EntityMetadata, entityWithIds: Subject[] = []): Promise<Subject[]> {\n        const promises = metadata.relations.map(relation => {\n            const relMetadata = relation.inverseEntityMetadata;\n\n            const value = relation.getEntityValue(entity);\n            if (!value)\n                return undefined;\n\n            if (value instanceof Array) {\n                const subPromises = value.map((subEntity: any) => {\n                    return this.extractObjectsById(subEntity, relMetadata, entityWithIds);\n                });\n                return Promise.all(subPromises);\n\n            } else {\n                return this.extractObjectsById(value, relMetadata, entityWithIds);\n            }\n        });\n\n        return Promise.all<any>(promises.filter(result => !!result)).then(() => {\n            if (!entityWithIds.find(entityWithId => entityWithId.entity === entity)) {\n                const entityWithId = new Subject(metadata, entity);\n                entityWithIds.push(entityWithId);\n            }\n\n            return entityWithIds;\n        });\n    }  */\n\n// }"],"sourceRoot":".."}